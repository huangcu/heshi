1.JVM -- java virtual machineJVM就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，
所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，
而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。
2.JRE -- java runtime environment
JRE是指java运行环境。光有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。
在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。
所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了。（jre里有运行.class的java.exe）
3.JDK -- java development kit
JDK是java开发工具包
在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。
其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、 jre。

现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。
bin:最主要的是编译器(javac.exe)
include:java和JVM交互用的头文件
lib：类库
jre:java运行环境

1: JAVA TYPE
primitive type: 
Numeric primitives: short(16), int(32), long(64), float(32) and double(64).
Textual primitives: byte(8) and char(16).
Boolean(1) and null primitives: boolean and null
in java default(infer): int and double
Object type :
2: Object super class of all class 
  public boolean equals(Object obj)
  public native int hashCode()
  Public String toString()
  protected native Object clone()
  protected void finalize()
  public final native Class<?> getClass()
  public final native void notify()
  public final native void notifyAll()
  public final native void wait()
  public final native void wait(long timeout)
  public final native void wait(long timeout, int nanos)
A Java class inherits these methods and can override any method that's not declared final

A native method is a Java method (either an instance method or a class method) whose implementation is written in another programming language such as C
3: Final VS Static (https://stackoverflow.com/questions/8005250/difference-between-a-static-and-a-final-static-variable-in-java)
  variables
    variables are declared in methods, and used as some kind of mutable local storage (int x; x = 5; x++)
  final variables
    final variables are also declared in methods, and are used as an immutable local storage (final int y; y = 0; y++; // won't compile).
  fields
    fields define the mutable state of objects, and are declared in classes
  final fields
    final fields define the immutable state of objects, are declared in classes and must be initialized before the constructor finishes (class x { final int myField = 5; }). They cannot be modified.
  static fields
    static fields are shared among all instances of any class. You can think of them as some kind of global mutable storage (class x { static int globalField = 5; })
  final static fields
    final static fields are global constants 

4: Exception, RunTimeException, Error

5: String StringBuffer StringBuilder
Both StringBuffer and StringBuilder are two important classes in Java which represents mutable String i.e. the String object, whose value can be changed. 
Since String is Immutable in Java, any change or operation on String object e.g. 
converting it to upper or lower case, adding character, removing a character, or getting a substring, 
all results in a new String object. This can put a lot of pressure on Garbage collector if your application generates lots of throws away String instances. 
To avoid this issue, Java designer presented initially StringBuffer class and later StringBuilder as mutable String. 

STRING:
String in immutable and final in Java and JVM uses String Pool to store all the String objects.
Some other interesting things about String is the way we can instantiate a String object using double quotes and overloading of “+” operator for concatenation.
When we create a String using double quotes, JVM looks in the String pool to find if any other String is stored with the same value. 
If found, it just returns the reference to that String object else it creates a new String object with given value and stores it in the String pool.
When we use the new operator, JVM creates the String object but don’t store it into the String Pool. 
We can use intern() method to store the String object into String pool or return the reference if there is already a String with equal value present in the pool.


Why character array is better than String for Storing password in Java
1) Since Strings are immutable in Java if you store password as plain text it will be available in memory until Garbage collector clears it and since String are used in String pool for reusability there is pretty high chance that it will be remain in memory for long duration, which pose a security threat. Since any one who has access to memory dump can find the password in clear text and that's another reason you should always used an encrypted password than plain text. Since Strings are immutable there is no way contents of Strings can be changed because any change will produce new String, while if you char[] you can still set all his element as blank or zero. So Storing password in character array clearly mitigates security risk of stealing password.
2) Java itself recommends using getPassword() method of JPasswordField which returns a char[] and deprecated getText() method which returns password in clear text stating security reason. Its good to follow advice from Java team and adhering to standard rather than going against it.
3) With String there is always a risk of printing plain text in log file or console but if use Array you won't print contents of array instead its memory location get printed. though not a real reason but still make sense.

Why String is immutable?
String is immutable for several reasons:  caching, security, synchronization, and performance.
  - Security: parameters are typically represented as String in network connections, database connection urls, 
  usernames/passwords etc. If it were mutable, these parameters could be easily changed.
  - Synchronization and concurrency: making String immutable automatically makes them thread safe 
  thereby solving the synchronization issues.
  - Caching: when compiler optimizes your String objects, 
  it sees that if two objects have same value (a="test", and b="test") and thus you need only one string object (for both a and b, these two will point to the same object).
  - Class loading: String is used as arguments for class loading. 
  If mutable, it could result in wrong class being loaded (because mutable objects change their state).

6: Sleep(), Wait(), Notify(), NotifyAll()
wait(), notify(), and notifyAll() methods of object class must have to be called inside synchronized method or synchronized block in Java

The key difference between wait() and sleep() is that former is used for inter-thread communication while later is used to introduced to pause the current thread for a short duration. This difference is more obvious from the fact that, when a thread calls the wait() method, it releases the monitor or lock it was holding on that object, but when a thread calls the sleep() method, it never releases the monitor even if it is holding. 
https://javarevisited.blogspot.com/2011/12/difference-between-wait-sleep-yield.html#ixzz5mSoDsHkl

Synchronized is to provide mutual exclusion and ensuring thread safety of Java class like race condition while wait and notify are communication mechanism between two thread.
Read more: https://javarevisited.blogspot.com/2012/02/why-wait-notify-and-notifyall-is.html#ixzz5mSxfZzRz

7: How hashmap internally works in java
hashCode(), equals()
https://www.journaldev.com/21095/java-equals-hashcode 
https://netjs.blogspot.com/2015/05/how-hashmap-internally-works-in-java.html

HashMap works on the principal of hashing.
HashMap in Java uses the hashCode() method to calculate a hash value. Hash value is calculated using the key object.
 This hash value is used to find the correct bucket where Entry object will be stored.
HashMap uses the equals() method to find the correct key whose value is to be retrieved in case of get() 
and to find if that key already exists or not in case of put().
With in the internal implementation of HashMap hashing collision means more than one key having the same hash value, in that case Entry objects are stored as a linked-list with in a same bucket.
With in a bucket values are stored as Entry objects which contain both key and value.
In Java 8 hash elements use balanced trees instead of linked lists after a certain threshold is reached while storing values. This improves the worst case performance from O(n) to O(log n).

override hashCode and equals together 
key-> bucket -> (equals)

Why String is popular HashMap key in Java ?
Since String is immutable, its hashcode is cached at the time of creation and 
it doesn’t need to be calculated again. This makes it a great candidate for key in a Map and its processing is fast than other HashMap key objects. 
This is why String is mostly used Object as HashMap keys.

How get method of HashMap and hashtable works internally in Java
http://www.java67.com/2013/06/how-get-method-of-hashmap-or-hashtable-works-internally.html
a) Key.hashCode() method is used to find the bucket location in backing array. 
  (Remember HashMap is backed by array in Java)
b) In backing array or better known as the bucket, key and values are stored in the form of a nested class called Entry
  If there is only one Entry at bucket location, then the value from that entry is returned.

What happens if two keys have the same hashCode? 
If multiple keys have the same hashCode, then during put() operation collision had occurred, 
which means multiple Entry objects stored in a bucket location. 
Each Entry keeps track of another Entry, forming a linked list data structure there.
Now, if we need to retrieve value object in this situation, following steps will be followed :
1) Call hashCode() method of the key to finding bucket location.
2) Traverse thought linked list, comparing keys in each entries using keys.equals() until it returns true.


9: modCount
ConcurrentModificationException   -> 
copyonwritearraylist ->"snapshot style"
Iterator returned by CopyOnWriteArrayList in Java is fail-safe, 
it uses a reference to the state of the array at the point that the iterator was created. 
You know by now any mutation will result in a fresh copy of the underlying array. 
Thus the array that the iterator has a reference to never changes during the lifetime of the iterator
1: The iterator will not reflect additions, removals, or changes to the list since the iterator was created thus it is also known as "snapshot style" iterator.
2: Element-changing operations on iterators themselves (remove, set, and add) are not supported. These methods throw UnsupportedOperationException.

https://www.journaldev.com/1289/copyonwritearraylist-java
https://netjs.blogspot.com/2016/01/copyonwritearraylist-in-java.html
fail-fast VS fail safe


The Collection subclass maintains an integer modCount that is incremented on every operation that structurally modifies the collection (like add, remove, clear).
The fail-fast iterators also contain an integer field expectedModCount which is initialized to the modCount while the iterator is created. 
Later on, during every iteration, the iterator verifies if the expectedModCount is same as the modCount of the collection it is iterating over.
A mismatch means that the collection has been modified during the life cycle of the iterator and a ConcurrentModificationException is thrown.

10: dynamic binding VS static binding
Can we override static method in Java? - Method Hiding

No, you cannot override static method in Java because method overriding is based upon dynamic binding at runtime 
and static methods are bonded using static binding at compile time. 
Though you can declare a method with same name and method signature in sub class 
which does look like you can override static method in Java but in reality that is method hiding. 
Java won't resolve method call at runtime and depending upon type of Object which is used to call static method, corresponding method will be called. 
It means if you use Parent class's type to call static method, original static will be called from patent class, 
on ther other hand if you use Child class's type to call static method, method from child class will be called. 
In short you can not override static method in Java.

11: Java 8 static and default method on Interface
11: Abstract VS Interface 
the main difference between an abstract class and interface in Java 8 is the fact that an abstract class is a class and an interface is an interface. A class can have a state which can be modified by non-abstract methods but an interface cannot have the state because they can't have instance variables.
The second difference is that an interface cannot have a constructor even in Java 8 but you may remember that abstract class can also have a constructor in Java. All methods of an interface were abstract but since Java 8 you can define non-abstract methods in the form of default and static methods inside interface in Java.

12: Can abstract class have Constructor in Java 
Yes, an abstract class can have a constructor in Java. 
You can either explicitly provide a constructor to abstract class or if you don't, 
the compiler will add default constructor of no argument in abstract class.
 This is true for all classes and it also applies to an abstract class. 
 For those who want to recall what is an abstract class in Java, 
 it's a class which can not be instantiated with new() operator or any other ways. 
 In order to use an abstract class in Java,  You need to extend it and provide a concrete class.

13: Why can an abstract class have a constructor in Java?
if we can not create an instance of an abstract class then why do Java adds a constructor in the abstract class. 
One of the reasons which make sense is  when any class extends an abstract class,
 the constructor of sub class will invoke the constructor of super class either implicitly or explicitly.
  This chaining of constructors is one of the reasons abstract class can have constructors in Java.

14: Overloading Overridding Hiding 
You can hide a field or variable in Java. 
A field is said to be hidden by another field if they have the same name in both parent and child class. 
For example, if Parent class has a name field and Child class also have age field then Child.age will hide Parent.age in the Child class.

if you have two static or private methods with the same name in both Parent and Child class 
then the method in Child class will hide the method from the Parent class

15: thread -> run(), start() 
when you call start() method it creates new Thread and executes code declared in the run() 
while directly calling run() method doesn’t create any new thread and execute code on the same calling thread.

15: Java 8 features 
  Interface changes with default and static methods
    default method: help us in extending interfaces with additional methods, all we need is to provide a default implementation. no need to override, but we can override them
    static methods: visible to interface methods only, we can’t override them in the implementation classes.
  Functional interfaces and Lambda Expressions
    An interface with exactly one abstract method is known as Functional Interface.
  Java Stream API for collection classes
  Java Date Time API

16: ArrayList LinkedList
Main difference between ArrayList and LinkedList is that 
ArrayList is implemented using re sizable array
 while LinkedList is implemented using doubly LinkedList.

1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 
2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 
3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 

ArrayList内部是使用可増长数组实现的，所以是用get和set方法是花费常数时间的，但是如果插入元素和删除元素，除非插入和删除的位置都在表末尾，
否则代码开销会很大，因为里面需要数组的移动。ArrayList更适合读取数据.

ArrayList 是线性表（数组）， 
get() 直接读取第几个下标，复杂度O（1）
add(E) 添加元素， 直接在后面添加 ， 复杂度 O(1)
add(index, E) 添加元素， 在第几个元素后面插入，后面元素需要向后移动，复杂度 O(n)
remove() 删除元素，后面元素需要逐个移动， 复杂度O(n)，除非删除最后一个 

LinkedList是使用双链表实现的，所以get会非常消耗资源，除非位置离头部很近。但是插入和删除元素花费常数时间。 linkedList更多的时候添加或删除数据。
LinkedList 是链表的操作 
get() 获取第几个元素 ，依次遍历，复杂度O（n）
add(E) 添加元素， 直接在后面添加 ， 复杂度 O(1)
add(index, E) 添加元素， 需要先查找到第几个元素，直接指针指向操作，复杂度 O(n)
remove() 删除元素，直接指针指向操作， 复杂度O(1)

Arraylist：底层是基于动态数组(Arraylist可以进行扩容)，根据下表随机访问数组元素的效率高，向数组尾部添加元素的效率高；
但是，删除数组中的数据以及向数组中间添加数据效率低，因为需要移动数组。
例如最坏的情况是删除第一个数组元素，则需要将第2至第n个数组元素各向前移动一位。